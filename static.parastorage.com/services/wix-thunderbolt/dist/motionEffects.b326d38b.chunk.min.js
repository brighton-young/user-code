"use strict";
(self.webpackJsonp__wix_thunderbolt_app =
  self.webpackJsonp__wix_thunderbolt_app || []).push([
  [5097],
  {
    49828: function (t, e, i) {
      i.r(e),
        i.d(e, {
          MotionEffectsInit: function () {
            return m;
          },
          MotionEffectsInitSymbol: function () {
            return c.J0;
          },
          MotionEffectsManager: function () {
            return l;
          },
          page: function () {
            return b;
          },
        });
      var n = i(77748),
        s = i(20590),
        r = i(39218),
        a = i(32166),
        o = i(54157),
        c = i(89301),
        h = i(3040);
      const d = (t) => `${t}-motionEffects`;
      Array.prototype.findLast ||
        Object.defineProperty(Array.prototype, "findLast", {
          value(t, e) {
            return this.slice(0)
              .reverse()
              .find(e ? t.bind(e) : t);
          },
        });
      class l {
        constructor(t, e, i) {
          (this.isResponsive = e),
            (this.breakpointRanges = []),
            (this.animator = t),
            (this.definitions = {}),
            (this.scrubScenes = {}),
            (this.scrubTriggers = {}),
            (this.callbacks = {}),
            (this.sessionState = { played: new Map(), running: new WeakMap() }),
            (this.scrubManagers = []),
            (this.activeListeners = []),
            (this.disabledPointerScenes = {}),
            (this.variantValidator = i),
            (this.breakpointChangeHandler =
              this._breakpointChangeHandler.bind(this));
        }
        _shouldSkipPlayedAnimation(t) {
          const e = this.sessionState.played.has(t),
            { playOnce: i, persistOnNav: n } =
              this.sessionState.played.get(t) || {};
          return e && (i || n);
        }
        setAnimationStartState(t) {
          const e = "string" == typeof t ? document.getElementById(t) : t;
          e && (e.dataset.motionEnter = "done");
        }
        _addAnimatingClass(t) {
          t &&
            (t.classList.add("is-animating"), this.setAnimationStartState(t));
        }
        _removeAnimatingClass(t) {
          t &&
            (t.classList.remove("is-animating"),
            this.setAnimationStartState(t));
        }
        updateDefinitions(t) {
          Object.assign(this.definitions, t);
          const e = Object.keys(t);
          this.updateScrubScenes(e);
        }
        updateScrubScenes(t, e = !1) {
          if (e) {
            const t = new Set();
            for (const e in this.scrubScenes)
              t.add(this.scrubScenes[e].targetId),
                this.scrubScenes[e].animation?.kill();
            (this.scrubScenes = {}), this.animator.clearScrubAnimations(t);
          }
          const i = {},
            n = this.isResponsive ? window.innerWidth : 0;
          for (const e of t) {
            const t = this._getEffectVariationForCurrentBreakpoint(e, n);
            "ScrubAnimationOptions" === t.type && (i[e] = t);
          }
          this.scrubScenes = Object.assign(
            this.scrubScenes,
            this.animator.createScrubAnimations(i)
          );
        }
        updateScrubManagers(t = {}, e = !1) {
          this.scrubManagers.length && e && this._killScrubAnimations(),
            this.scrubManagers.push(
              ...this.animator.startScrubAnimations(t, this.scrubScenes)
            ),
            this.scrubManagers.forEach((t) => {
              t instanceof h.g &&
                t.config.scenes.forEach((t) => {
                  if (t.target && t.centeredToTarget && t.isHitAreaRoot) {
                    const e = t.target.closest("[data-block-level-container]"),
                      i = t.effectId;
                    e &&
                      this.motionViewport &&
                      i &&
                      (this.disabledPointerScenes[i] ||
                        (this.disabledPointerScenes[i] = []),
                      this.disabledPointerScenes[i].push(t),
                      this.motionViewport.observe(e, {
                        effectId: i,
                        targetId: t.target.id,
                      }));
                  }
                });
            });
        }
        handleRotation(t, e) {
          (t.dataset.angle = String(e)),
            (t.dataset.angleStyleLocation = "style");
        }
        trigger(t = {}, e) {
          let i = 0;
          t.scrub
            ? e
              ? ((this.scrubTriggers = t.scrub),
                requestAnimationFrame(() =>
                  this.updateScrubManagers(t.scrub, e)
                ))
              : (Object.assign(this.scrubTriggers, t.scrub),
                this.updateScrubManagers(t.scrub))
            : (i = this.isResponsive ? window.innerWidth : 0),
            t.play?.length &&
              t.play.forEach(({ effectId: t, targetId: e }) => {
                const n = this._getEffectVariationForCurrentBreakpoint(t, i);
                n.name && this.playAnimation(n, t, { targetId: e });
              }),
            t.resume?.length &&
              t.resume.forEach(({ effectId: t, targetId: e }) => {
                if (this.disabledPointerScenes[t])
                  return void this.disabledPointerScenes[t].forEach(
                    (t) => (t.disabled = !1)
                  );
                const n = this._getEffectVariationForCurrentBreakpoint(t, i);
                n.name && this.resumeOrPlayAnimation(n, t, { targetId: e });
              }),
            t.hold?.length &&
              t.hold.forEach(({ effectId: t, targetId: e }) => {
                if (this.disabledPointerScenes[t])
                  return void this.disabledPointerScenes[t].forEach(
                    (t) => (t.disabled = !0)
                  );
                const n = this._getEffectVariationForCurrentBreakpoint(t, i);
                n.name && this.pauseAnimation({ ...n, targetId: e });
              });
        }
        init(t, e) {
          (this.breakpointRanges = e),
            this.stopAnimations(),
            (this.definitions = {}),
            this.observeBreakpointChange(),
            this.updateDefinitions(t);
        }
        addDefinition(t, e, i) {
          this.handleRotation(e, i), this.updateDefinitions(t);
        }
        addEffectCallback(t, e, i) {
          const n = "animation-end" === e ? "end" : "start";
          (this.callbacks[t] = this.callbacks[t] || { end: [], start: [] }),
            this.callbacks[t][n]?.push(i);
        }
        clearEffectCallbacks(t) {
          delete this.callbacks[t];
        }
        observeTargetPlaybackInViewport(t, e) {
          const i = document.getElementById(e);
          if (i && this.motionViewport) {
            const n = i.closest("[data-block-level-container]") || i;
            this.motionViewport.observe(n, { effectId: t, targetId: e });
          }
        }
        playAnimation(t, e, i = {}) {
          const n = { ...t, ...i },
            { targetId: s, iterations: r } = n,
            a = d(s);
          this._shouldSkipPlayedAnimation(a)
            ? this.setAnimationStartState(s)
            : 0 !== r
            ? this._createAndRunSequence(n, e)
            : this.observeTargetPlaybackInViewport(e, s);
        }
        _createAndRunSequence(t, e = "") {
          const {
              name: i,
              targetId: n,
              duration: s,
              delay: r,
              easing: a,
              params: o,
              playOnce: c,
              persistOnNav: h,
              iterations: l = 1,
            } = t,
            f = d(n),
            u = {
              name: i,
              targetId: n,
              duration: s,
              delay: r,
              params: { ...o, easing: a },
            },
            g = {
              name: "BaseClear",
              targetId: n,
              duration: 0,
              delay: 0,
              params: {
                props:
                  "clip,clipPath,webkitClipPath,willChange,opacity,transform,transformOrigin,filter",
                immediateRender: !1,
              },
            },
            m = this.animator.runSequence(
              [
                { type: "Animation", data: u },
                { type: "Animation", data: g },
              ],
              {
                repeat: l - 1,
                callbacks: {
                  onStart: (t) => {
                    const i = document.getElementById(n);
                    i &&
                      (this._addAnimatingClass(i),
                      this.sessionState.running.set(i, t)),
                      e &&
                        this.callbacks[e]?.start?.forEach((t) =>
                          t({ compId: n })
                        );
                  },
                  onComplete: () => {
                    const t = document.getElementById(n);
                    t &&
                      (this._removeAnimatingClass(t),
                      this.sessionState.running.delete(t)),
                      e &&
                        this.callbacks[e]?.end?.forEach((t) =>
                          t({ compId: n })
                        );
                  },
                  onInterrupt: () => {
                    const t = document.getElementById(n);
                    t &&
                      (this._removeAnimatingClass(t),
                      this.sessionState.running.delete(t));
                  },
                },
              }
            );
          this.sessionState.played.set(f, {
            playOnce: c,
            persistOnNav: h,
            instance: m,
          });
        }
        _getEffectVariationForCurrentBreakpoint(t, e) {
          const i = this.definitions[t].find((t) => !t.variants?.length);
          return this.variantValidator(i, t, e);
        }
        stopAnimations({ skipPersistent: t = !0 } = {}) {
          this.sessionState.played.forEach(
            ({ persistOnNav: e, instance: i }) => {
              (t && e) || this.animator.kill(i.timeline, 1);
            }
          ),
            this._killScrubAnimations();
        }
        getSequenceFromState(t) {
          const e = document.getElementById(t.targetId);
          return e && this.sessionState.running.get(e);
        }
        resumeOrPlayAnimation(t, e, i = {}) {
          const n = { ...t, ...i },
            s = this.getSequenceFromState(n);
          s ? s.play() : this._createAndRunSequence(n, e);
        }
        pauseAnimation(t) {
          const e = this.getSequenceFromState(t);
          e?.pause();
        }
        _killScrubAnimations() {
          this.scrubManagers.length &&
            (this.scrubManagers.forEach((t) => t.destroy()),
            (this.scrubManagers.length = 0),
            (this.disabledPointerScenes = {}));
        }
        clearAnimations() {
          (this.definitions = {}),
            this._killScrubAnimations(),
            this.motionViewport?.disconnect(),
            this.activeListeners.forEach((t) =>
              t.removeEventListener("change", this.breakpointChangeHandler)
            ),
            (this.activeListeners.length = 0),
            (this.scrubTriggers = {});
        }
        clearState() {
          this.sessionState.played.clear(),
            (this.sessionState.running = new WeakMap());
        }
        observeBreakpointChange() {
          this.breakpointRanges.forEach((t) => {
            const e = ((t) => {
                const e = [];
                return (
                  t.max && e.push(`(max-width:${t.max}px)`),
                  t.min && e.push(`(min-width:${t.min}px)`),
                  e.join(" and ")
                );
              })(t),
              i = window.matchMedia(e);
            this.activeListeners.push(i),
              i.addEventListener("change", this.breakpointChangeHandler);
          });
        }
        _breakpointChangeHandler(t) {
          t.matches &&
            this.updateScrubScenes(Object.keys(this.definitions), !0);
        }
      }
      var f = i(83407),
        u = i(82658);
      const g = function (t, e, i) {
          return (
            (i &&
              this.definitions[e].findLast((t) =>
                t.variants?.some(
                  (t) => !(t.max && t.max < i) && !(t.min && t.min > i)
                )
              )) ||
            t
          );
        },
        m = (0, n.Og)(
          [
            (0, n.KT)(s.Gp, c.UU),
            (0, n.KT)(s.wk, c.UU),
            r.Is,
            a.RV,
            o.n,
            (0, n.lq)(f.Qw),
          ],
          (t, e, i, n, s, r) => {
            const a = new Promise((n) => {
              const {
                animationDefsByCompId: a,
                isResponsive: o,
                scrubAnimationBreakpoints: c,
              } = t;
              (r && !s) || n(void 0),
                r.getEffectsInstance().then((t) => {
                  const s = e.get()?.[i] ?? new l(t, o, g),
                    r = Object.assign({}, ...Object.values(a));
                  (s.motionViewport =
                    s.motionViewport ??
                    (function ({ manager: t }) {
                      const e = {
                          entry: n(
                            function (e) {
                              const n = e
                                .filter((t) => {
                                  const { isIntersecting: e, target: n } = t;
                                  return e && (i.get(n).isIntersecting = !0), e;
                                })
                                .flatMap((t) => s(t.target));
                              t.trigger({ resume: n });
                            },
                            0,
                            "10%"
                          ),
                          exit: n(
                            function (e) {
                              const n = e
                                .filter((t) => {
                                  const { isIntersecting: e, target: n } = t;
                                  return (
                                    e || (i.get(n).isIntersecting = !1), !e
                                  );
                                })
                                .flatMap((t) => s(t.target));
                              t.trigger({ hold: n });
                            },
                            0,
                            "50%"
                          ),
                        },
                        i = new WeakMap();
                      function n(t, e, i = "0px") {
                        const n = { root: null, rootMargin: i, threshold: [e] };
                        return new window.IntersectionObserver(t, n);
                      }
                      const s = (t) => Array.from(i.get(t)?.effects || []);
                      return {
                        observe: function (n, s) {
                          const r = i.get(n);
                          r
                            ? (r.effects.add(s),
                              r.isIntersecting && t.trigger({ resume: [s] }))
                            : (i.set(n, {
                                effects: new Set([s]),
                                isIntersecting: !1,
                              }),
                              e.entry.observe(n),
                              e.exit.observe(n));
                        },
                        disconnect: function () {
                          e.entry.disconnect(), e.exit.disconnect();
                        },
                      };
                    })({ manager: s })),
                    s.init(r, c),
                    e.update((t) => ({ ...t, [i]: s })),
                    n(s);
                });
            });
            return s && !(0, u.fU)(n)
              ? {
                  name: "motionEffectsInit",
                  pageWillUnmount() {},
                  getInstance() {
                    return a;
                  },
                }
              : {
                  name: "motionEffectsInit",
                  async pageWillUnmount() {
                    const t = await a;
                    t?.clearAnimations();
                  },
                  getInstance() {
                    return a;
                  },
                };
          }
        );
      var p = i(16537);
      const b = (t) => {
        t(p.$.PageWillUnmountHandler, c.J0).to(m);
      };
    },
    3040: function (t, e, i) {
      function n(t, e, i) {
        return Math.min(Math.max(t, i), e);
      }
      i.d(e, {
        g: function () {
          return c;
        },
      });
      const s = { x: 0, y: 0 };
      function r(t, e) {
        (s.x = window.scrollX),
          (s.y = window.scrollY),
          requestAnimationFrame(() => t && t(e));
      }
      function a(t) {
        (t.rect.width = window.visualViewport.width),
          (t.rect.height = window.visualViewport.height);
      }
      function o(t) {
        let e,
          i,
          o,
          c,
          h = !1,
          d = { x: t.rect.width / 2, y: t.rect.height / 2, vx: 0, vy: 0 };
        return (
          t.scenes.forEach((e) => {
            var n, r;
            e.target &&
              e.centeredToTarget &&
              ((e.transform =
                ((n = (function (t) {
                  let e = t,
                    i = 0,
                    n = 0;
                  if (e.offsetParent)
                    do {
                      (i += e.offsetLeft),
                        (n += e.offsetTop),
                        (e = e.offsetParent);
                    } while (e);
                  return {
                    left: i,
                    top: n,
                    width: t.offsetWidth,
                    height: t.offsetHeight,
                  };
                })(e.target)),
                (r = t.rect),
                {
                  x(t) {
                    const e = n.left - s.x + n.width / 2,
                      i = e >= r.width / 2,
                      a = 2 * (i ? e : r.width - e);
                    return (t - (i ? 0 : e - a / 2)) / a;
                  },
                  y(t) {
                    const e = n.top - s.y + n.height / 2,
                      i = e >= r.height / 2,
                      a = 2 * (i ? e : r.height - e);
                    return (t - (i ? 0 : e - a / 2)) / a;
                  },
                })),
              (h = !0)),
              t.root
                ? (i = (function (t) {
                    const e = new ResizeObserver((e) => {
                      e.forEach((e) => {
                        (t.rect.width = e.borderBoxSize[0].inlineSize),
                          (t.rect.height = e.borderBoxSize[0].blockSize);
                      });
                    });
                    return e.observe(t.root, { box: "border-box" }), e;
                  })(t))
                : ((o = a.bind(null, t)), window.addEventListener("resize", o));
          }),
          (e = function (e) {
            for (let i of t.scenes)
              if (!i.disabled) {
                const s = +n(
                    0,
                    1,
                    i.transform?.x(e.x) || e.x / t.rect.width
                  ).toPrecision(4),
                  r = +n(
                    0,
                    1,
                    i.transform?.y(e.y) || e.y / t.rect.height
                  ).toPrecision(4),
                  a = { x: e.vx, y: e.vy };
                i.effect(i, { x: s, y: r }, a);
              }
            Object.assign(d, e);
          }),
          h &&
            ((c = r.bind(null, e, d)),
            document.addEventListener("scrollend", c)),
          {
            tick: e,
            destroy: function () {
              t.scenes.forEach((t) => t.destroy?.()),
                document.removeEventListener("scrollend", c),
                i
                  ? (i.disconnect(), (i = null))
                  : (window.removeEventListener("resize", o), (o = null)),
                (e = null),
                (d = null);
            },
          }
        );
      }
      class c {
        constructor(t = {}) {
          (this.config = { ...t }),
            (this.effect = null),
            (this._nextTick = null);
          const e = (function (t) {
            let e = !1;
            return function () {
              if (!e)
                return (
                  (e = !0),
                  window.requestAnimationFrame(() => {
                    (e = !1), t();
                  })
                );
            };
          })(() => {
            this.tick();
          });
          (this.config.rect = this.config.root
            ? {
                width: this.config.root.offsetWidth,
                height: this.config.root.offsetHeight,
              }
            : {
                width: window.visualViewport.width,
                height: window.visualViewport.height,
              }),
            (this.progress = {
              x: this.config.rect.width / 2,
              y: this.config.rect.height / 2,
              vx: 0,
              vy: 0,
            }),
            (this._measure = (t) => {
              (this.progress.x = this.config.root ? t.offsetX : t.x),
                (this.progress.y = this.config.root ? t.offsetY : t.y),
                (this.progress.vx = t.movementX),
                (this.progress.vy = t.movementY),
                (this._nextTick = e());
            });
        }
        start() {
          this.setupEffect(), this.setupEvent();
        }
        pause() {
          this.removeEvent();
        }
        tick() {
          this.effect.tick(this.progress);
        }
        destroy() {
          this.pause(),
            this.removeEffect(),
            this._nextTick && cancelAnimationFrame(this._nextTick);
        }
        setupEvent() {
          this.removeEvent();
          (this.config.root || window).addEventListener(
            "pointermove",
            this._measure,
            { passive: !0 }
          );
        }
        removeEvent() {
          (this.config.root || window).removeEventListener(
            "pointermove",
            this._measure
          );
        }
        setupEffect() {
          this.removeEffect(), (this.effect = o(this.config));
        }
        removeEffect() {
          this.effect && this.effect.destroy(), (this.effect = null);
        }
      }
    },
  },
]);
//# sourceMappingURL=https://static.parastorage.com/services/wix-thunderbolt/dist/motionEffects.b326d38b.chunk.min.js.map
