import {
  getScreenHeight,
  setStyle,
  getImageComputedProperties,
  getImageSrc,
  isTransformedWEBP,
} from "./utils";
const MOBILE_SAFE_ADDRESSBAR_HEIGHT = 80;
function getHeightOverride(height, mediaHeightOverrideType) {
  // on mobile, documentElement.clientHeight changes when scrolling, because of address bar collapsing.
  // avoiding re-fetching image by returning the same height
  return mediaHeightOverrideType === "fixed" ||
    mediaHeightOverrideType === "viewport"
    ? document.documentElement.clientHeight + MOBILE_SAFE_ADDRESSBAR_HEIGHT
    : height;
}
function computeScaleOverrides(imageStyle, targetScale = 1) {
  return targetScale !== 1
    ? {
        ...imageStyle,
        width: "100%",
        height: "100%",
      }
    : imageStyle;
}
/**
 * compute specific overrides
 */
function computeStyleOverrides(
  mediaHeightOverrideType,
  imageStyle,
  displayMode,
  targetScale,
  isResponsive
) {
  // image scaling override
  const styleWithScale = computeScaleOverrides(imageStyle, targetScale);
  if (isResponsive) {
    delete styleWithScale.height;
    styleWithScale.width = "100%";
  }
  if (!mediaHeightOverrideType) {
    return styleWithScale;
  }
  // siteBackground on mobile
  const style = { ...styleWithScale };
  if (displayMode === "fill") {
    style.position = "absolute";
    style.top = "0";
  } else if (displayMode === "fit") {
    style.height = "100%";
  }
  if (mediaHeightOverrideType === "fixed") {
    // eliminates white gap when address bar is collapsing
    style["will-change"] = "transform";
  }
  // force image alignment to include top
  if (style.objectPosition) {
    style.objectPosition = imageStyle.objectPosition.replace(
      /(center|bottom)$/,
      "top"
    );
  }
  return style;
}
function getSourceSetsTargetHeightByEffect(
  sourceSets,
  offsetWidth,
  offsetHeight,
  screenHeight,
  services
) {
  const sourceSetsTargetHeights = {};
  sourceSets.forEach(({ mediaQuery, scrollEffect }) => {
    sourceSetsTargetHeights[mediaQuery] = services.getMediaDimensionsByEffect(
      scrollEffect,
      offsetWidth,
      offsetHeight,
      screenHeight
    ).height;
  });
  return sourceSetsTargetHeights;
}
function computeSrcSets(measures, imageInfo, envConsts) {
  const { sourceSets } = imageInfo;
  if (!sourceSets || !sourceSets.length) {
    return;
  }
  const mediaToUri = {};
  sourceSets.forEach(({ mediaQuery, crop, focalPoint }) => {
    const imageInfoClone = {
      ...imageInfo,
      targetHeight: (measures.sourceSetsTargetHeights || {})[mediaQuery] || 0,
      imageData: {
        ...imageInfo.imageData,
        crop,
        focalPoint,
      },
    };
    const imageComputedProperties = getImageComputedProperties(
      imageInfoClone,
      envConsts,
      "img"
    );
    mediaToUri[mediaQuery] = imageComputedProperties.uri || "";
  });
  return mediaToUri;
}
function measure(
  id,
  measures,
  domNodes,
  { containerElm, bgEffect = "none", sourceSets },
  services
) {
  const innerImage = domNodes.image;
  const wixImage = domNodes[id];
  const screenHeight = getScreenHeight(services.getScreenHeightOverride?.());
  // override positioning and scaling of image (SiteBackground mobile override behaviour)
  const mediaHeightOverrideType = containerElm?.dataset.mediaHeightOverrideType;
  const sourceOfDimensions =
    containerElm && bgEffect && bgEffect !== "none" ? containerElm : wixImage; // default to self
  const { width, height } = services.getMediaDimensionsByEffect?.(
    bgEffect,
    sourceOfDimensions.offsetWidth,
    sourceOfDimensions.offsetHeight,
    screenHeight
  ) || {
    width: wixImage.offsetWidth,
    height: wixImage.offsetHeight,
  };
  if (sourceSets) {
    measures.sourceSetsTargetHeights = getSourceSetsTargetHeightByEffect(
      sourceSets,
      sourceOfDimensions.offsetWidth,
      sourceOfDimensions.offsetHeight,
      screenHeight,
      services
    );
  }
  if (!innerImage) {
    return;
  }
  const imgSrc = getImageSrc(innerImage);
  measures.width = width;
  measures.height = getHeightOverride(height, mediaHeightOverrideType);
  measures.screenHeight = screenHeight;
  measures.imgSrc = imgSrc;
  measures.boundingRect = wixImage.getBoundingClientRect();
  measures.mediaHeightOverrideType = mediaHeightOverrideType;
}
function patch(
  id,
  measures,
  domNodes,
  imageInfo,
  services,
  envConsts,
  loadImage,
  isResponsive,
  bgEffect
) {
  if (!Object.keys(measures).length) {
    return;
  }
  const { imageData } = imageInfo;
  const wixImageNode = domNodes[id];
  const image = domNodes.image;
  // no retina scaling for background scroll effects
  if (bgEffect) {
    imageData.devicePixelRatio = 1;
  }
  const targetScale = imageInfo.targetScale || 1;
  const extendedImageInfo = {
    ...imageInfo,
    ...(!imageInfo.skipMeasure && {
      targetWidth: (measures.width || 0) * targetScale,
      targetHeight: (measures.height || 0) * targetScale,
    }),
    displayMode: imageData.displayMode,
  };
  // for TPAs that did not get specs.thunderbolt.allowWEBPTransformation in SSR & downloaded untransformed image, don't allow webp transformation
  const allowWEBPTransform =
    services.isExperimentOpen?.("specs.thunderbolt.allowWEBPTransformation") &&
    isTransformedWEBP(image, imageData.uri);
  const imageComputedProperties = getImageComputedProperties(
    extendedImageInfo,
    envConsts,
    "img",
    allowWEBPTransform
  );
  const computedStyle = imageComputedProperties?.css?.img || {};
  const imageStyle = computeStyleOverrides(
    measures.mediaHeightOverrideType,
    computedStyle,
    imageData.displayMode,
    targetScale,
    isResponsive
  );
  setStyle(image, imageStyle);
  const src = imageComputedProperties?.uri || "";
  wixImageNode.setAttribute("data-src", src);
  const mediaToUri = computeSrcSets(measures, extendedImageInfo, envConsts);
  // clear initial indication that the image src came from ssr render
  wixImageNode.setAttribute("data-has-ssr-src", "");
  if (
    imageInfo.isLQIP &&
    imageInfo.lqipTransition &&
    !("transitioned" in wixImageNode.dataset)
  ) {
    wixImageNode.dataset.transitioned = "";
    if (image.complete) {
      image.onload = function () {
        image.dataset.loadDone = "";
      };
    } else {
      image.onload = function () {
        if (image.complete) {
          image.dataset.loadDone = "";
        } else {
          image.onload = function () {
            image.dataset.loadDone = "";
          };
        }
      };
    }
  }
  if (loadImage) {
    image.setAttribute("fetchpriority", "high");
    image.currentSrc !== src && image.setAttribute("src", src);
    image.srcset && image.srcset !== src && image.setAttribute("srcset", src);
    if (domNodes.picture && extendedImageInfo.sourceSets) {
      Array.from(domNodes.picture.querySelectorAll("source")).forEach(
        (sourceNode) => {
          const mediaQuery = sourceNode.media || "";
          const uri = mediaToUri ? mediaToUri[mediaQuery] : "";
          sourceNode.srcset !== uri && sourceNode.setAttribute("srcset", uri);
        }
      );
    }
  }
}
export default {
  measure,
  patch,
};
//# sourceMappingURL=imageLayout.js.map
