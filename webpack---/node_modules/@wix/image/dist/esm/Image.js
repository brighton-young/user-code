import * as React from "react";
import styles from "./Image.scss";
import * as imageKit from "@wix/image-kit";
const { STATIC_MEDIA_URL } = imageKit;
const fetchLQIP = ({ fittingType, src, target, options }) => {
  const placeholder = imageKit.getPlaceholder(fittingType, src, target, {
    ...options,
    autoEncode: true,
  });
  if (placeholder?.uri && !/^[a-z]+:/.test(placeholder.uri)) {
    placeholder.uri = `${STATIC_MEDIA_URL}${placeholder.uri}`;
  }
  return placeholder;
};
const SCHEME_RE = /^[a-z]+:/;
const Image = (props) => {
  const {
    id,
    containerId,
    uri,
    alt,
    name = "",
    role,
    width,
    height,
    displayMode,
    devicePixelRatio,
    quality,
    alignType,
    bgEffectName = "",
    focalPoint,
    upscaleMethod,
    className = "",
    crop,
    imageStyles = {},
    targetWidth,
    targetHeight,
    targetScale,
    onLoad = () => {},
    onError = () => {},
    shouldUseLQIP,
    containerWidth,
    containerHeight,
    getPlaceholder,
    isInFirstFold,
    placeholderTransition,
    socialAttrs,
    isSEOBot,
    skipMeasure,
    lazyLoadImgExperimentOpen,
    hasAnimation,
    allowWEBPTransform,
  } = props;
  const imageRef = React.useRef(null);
  // fix containerId and id to support hoverBox component
  let hasSsrSrc = "";
  const hasBlurTransition = placeholderTransition === "blur";
  const ssrImageData = React.useRef(null);
  if (!ssrImageData.current) {
    if (getPlaceholder || shouldUseLQIP || isInFirstFold || isSEOBot) {
      const options = {
        upscaleMethod,
        ...(quality ? quality : {}),
        shouldLoadHQImage: isInFirstFold,
        isSEOBot,
        hasAnimation,
        allowWEBPTransform,
      };
      ssrImageData.current = (getPlaceholder || fetchLQIP)({
        fittingType: displayMode,
        src: {
          id: uri,
          width,
          height,
          crop,
          name,
          focalPoint,
        },
        target: {
          width: containerWidth,
          height: containerHeight,
          alignment: alignType,
          htmlTag: "img",
        },
        options,
      });
      hasSsrSrc =
        !ssrImageData.current.transformed || isInFirstFold || isSEOBot
          ? ""
          : "true";
    } else {
      // to keep an empty placeholder data
      ssrImageData.current = {
        uri: undefined,
        css: { img: {} },
        attr: { img: {}, container: {} },
        transformed: false,
      };
    }
  }
  const isLQIP =
    !isSEOBot &&
    (getPlaceholder || shouldUseLQIP) &&
    !isInFirstFold &&
    ssrImageData.current.transformed;
  const imageInfo = React.useMemo(
    () =>
      JSON.stringify({
        containerId,
        ...(containerId && { containerId }),
        ...(alignType && { alignType }),
        ...(skipMeasure && { skipMeasure: true }),
        displayMode,
        ...(containerWidth && { targetWidth: containerWidth }),
        ...(containerHeight && { targetHeight: containerHeight }),
        ...(targetWidth && { targetWidth }),
        ...(targetHeight && { targetHeight }),
        ...(targetScale && { targetScale }),
        isLQIP,
        isSEOBot,
        lqipTransition: placeholderTransition,
        imageData: {
          width,
          height,
          uri,
          name,
          displayMode,
          hasAnimation,
          ...(quality && { quality }),
          ...(devicePixelRatio && { devicePixelRatio }),
          ...(focalPoint && { focalPoint }),
          ...(crop && { crop }),
          ...(upscaleMethod && { upscaleMethod }),
        },
      }),
    [
      containerId,
      alignType,
      skipMeasure,
      displayMode,
      containerHeight,
      containerWidth,
      targetWidth,
      targetHeight,
      targetScale,
      isLQIP,
      isSEOBot,
      placeholderTransition,
      width,
      height,
      uri,
      name,
      quality,
      devicePixelRatio,
      focalPoint,
      crop,
      upscaleMethod,
      hasAnimation,
    ]
  );
  const ssrResult = ssrImageData.current;
  const src = ssrResult?.uri;
  const srcset = ssrResult?.srcset;
  const placeholderStyle = ssrResult.css?.img;
  const classNames = `${styles.image} ${className}`;
  React.useEffect(() => {
    // When image comes from cache onLoad not trigger on native HTML element
    const imgElment = imageRef.current;
    if (onLoad && imgElment?.currentSrc && imgElment?.complete) {
      onLoad({
        target: imageRef.current,
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const maxWidth =
    ssrResult && !ssrResult?.transformed
      ? `max(${width}px, 100%)`
      : targetWidth
      ? `${targetWidth}px`
      : null;
  return React.createElement(
    "wow-image",
    {
      id: id,
      class: classNames,
      "data-image-info": imageInfo,
      "data-bg-effect-name": bgEffectName,
      "data-has-ssr-src": hasSsrSrc,
      "data-animate-blur":
        !isSEOBot && isLQIP && hasBlurTransition ? "" : undefined,
      style: maxWidth ? { "--wix-img-max-width": maxWidth } : {},
    },
    React.createElement("img", {
      src: src,
      ref: imageRef,
      alt: alt || "",
      role: role,
      style: { ...placeholderStyle, ...imageStyles },
      onLoad: onLoad,
      onError: onError,
      ...(containerWidth && { width: containerWidth }),
      ...(containerHeight && { height: containerHeight }),
      ...socialAttrs,
      ...(isInFirstFold
        ? {
            srcSet: srcset?.dpr
              ?.map((s) => (SCHEME_RE.test(s) ? s : `${STATIC_MEDIA_URL}${s}`))
              .join(", "),
            fetchpriority: "high",
          }
        : lazyLoadImgExperimentOpen
        ? { loading: "lazy" }
        : {}),
    })
  );
};
export { Image, imageKit };
//# sourceMappingURL=Image.js.map
