import { onTTFB, onFCP, onLCP, onCLS, onINP } from "web-vitals/attribution";
import Queue from "./queue";
import { createPulseLogger } from "./utils/pulse-logger";
import {
  pulseError,
  pulseInitialized,
  pulseUpdated,
} from "@wix/bi-logger-pulse/v2";
import { logBiWithEssentials } from "./utils/log-bi-with-essential";
export class Pulse {
  _platform;
  _biLogger;
  _debug = false;
  _queues = new Map();
  _url = window.location.href;
  _pulseLogger;
  _sessionId;
  _vsi;
  _msid;
  _uuid;
  _getHtmlElementMetadata = () => ({});
  constructor(config) {
    this._platform = config.platform;
    // If a biLoggerFactory is provided, use it to create a biLogger instance.
    if (!config.biLoggerFactory && !config.biLogger) {
      throw new Error(`biLogger or biLoggerFactory must be provided`);
    }
    this._biLogger = config.biLoggerFactory
      ? config.biLoggerFactory({ useBatch: true }).logger()
      : config.biLogger;
    // We want to report Pulse initialization as soon as we can
    logBiWithEssentials(
      this._biLogger,
      pulseInitialized({
        sessionId: config.sessionId,
        platform: config.platform,
        ...(config.msid && { msid: config.msid }),
        ...(config.vsi && { vsi: config.vsi }),
        ...(config.uuid && { uuid: config.uuid }),
      })
    );
    this._debug = config.debug || false;
    this._sessionId = config.sessionId;
    this._vsi = config.vsi;
    this._msid = config.msid;
    this._uuid = config.uuid;
    if (config.getHtmlElementMetadata) {
      this._getHtmlElementMetadata = config.getHtmlElementMetadata;
    }
    const searchQuery = new URLSearchParams(window.location.search);
    this._pulseLogger = createPulseLogger(
      this._debug || searchQuery.has("debugPulse")
    );
    try {
      this._initListeners();
    } catch (e) {
      console.error("Failed to initialze Pulse listeners", e);
      this._reportErrorToBi(e, "Pulse Listeners Initialization");
    }
  }
  update({ getHtmlElementMetadata }) {
    // We want to report Pulse update as soon as we can
    try {
      logBiWithEssentials(
        this._biLogger,
        pulseUpdated({
          sessionId: this._sessionId,
          platform: this._platform,
          ...(this._msid && { msid: this._msid }),
          ...(this._vsi && { vsi: this._vsi }),
          ...(this._uuid && { uuid: this._uuid }),
        })
      );
      this._getHtmlElementMetadata = getHtmlElementMetadata;
      // Update all queues with the new getHtmlElementMetadata function
      for (const queue of this._queues.values()) {
        queue.getHtmlElementMetadata = this._getHtmlElementMetadata;
      }
    } catch (e) {
      console.error("Failed update Pulse", e);
      this._reportErrorToBi(e, "Pulse Update");
    }
  }
  addMetricToQueue(metric) {
    const { navigationType: navType } = metric;
    const navigationId = 1;
    if (!this._queues.has(navigationId.toString())) {
      this._queues.set(
        navigationId.toString(),
        new Queue({
          url: this._url,
          platform: this._platform,
          biLogger: this._biLogger,
          pulseLogger: this._pulseLogger,
          sessionId: this._sessionId,
          ...(this._vsi && { vsi: this._vsi }),
          ...(this._msid && { msid: this._msid }),
          ...(this._uuid && { uuid: this._uuid }),
          getHtmlElementMetadata: this._getHtmlElementMetadata,
          navigationId: navigationId.toString(),
          navType,
        })
      );
    }
    this._queues.get(navigationId.toString())?.addToQueue(metric);
  }
  _flushQueues() {
    for (const queue of this._queues.values()) {
      queue.flushQueue();
    }
  }
  _initListeners() {
    const promisify = (onXXX, options) =>
      new Promise((resolve) =>
        onXXX((metric) => {
          this.addMetricToQueue(metric);
          resolve(undefined);
        }, options)
      );
    const onLCPPromise = promisify(onLCP);
    const onFCPPromise = promisify(onFCP);
    const onTTFBPromise = promisify(onTTFB);
    const basicWebVitalsPromises = Promise.all([
      onTTFBPromise,
      onFCPPromise,
      onLCPPromise,
    ]);
    onCLS((metric) => {
      this.addMetricToQueue(metric);
      this._reportStepToBi("CLSEvent", "CLS event");
    });
    onINP((metric) => this.addMetricToQueue(metric), {
      reportAllChanges: true,
    });
    // We use Pulse error for debuggin purposes since adding more events and getting them approved
    // by data-pipelines is cumbersome
    // We will use the step property to differentiate between the different events
    onLCPPromise.then(() => {
      this._reportStepToBi("LCPPromise", "LCPPromise resolved");
    });
    onFCPPromise.then(() => {
      this._reportStepToBi("FCPPromise", "FCPPromise resolved");
    });
    onTTFBPromise.then(() => {
      this._reportStepToBi("TTFBPromise", "TTFBPromise resolved");
    });
    // Still using this so it will works for CLS and INP
    // Report all available metrics whenever the page is backgrounded or unloaded.
    addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        // We use Pulse error for debuggin purposes since adding more events and getting them approved
        // by data-pipelines is cumbersome
        // We will use the step property to differentiate between the different events
        this._reportStepToBi("Visibility Change", "Visibility change");
        basicWebVitalsPromises.then(() => {
          this._flushQueues();
        });
      }
    });
    // NOTE: Safari does not reliably fire the `visibilitychange` event when the
    // page is being unloaded. If Safari support is needed, you should also flush
    // the queue in the `pagehide` event.
    addEventListener("pagehide", () => {
      // Same explanation as above
      this._reportStepToBi("Visibility Change", "Visibility change pagehide");
      basicWebVitalsPromises.then(() => {
        this._flushQueues();
      });
    });
  }
  _reportErrorToBi(e, step) {
    logBiWithEssentials(
      this._biLogger,
      pulseError({
        platform: this._platform,
        sessionId: this._sessionId,
        ...(this._msid && { msid: this._msid }),
        ...(this._vsi && { vsi: this._vsi }),
        ...(this._uuid && { uuid: this._uuid }),
        message: e instanceof Error ? e.message : "No error message",
        step,
      })
    );
  }
  // TODO: Temporary method for debug purposes
  _reportStepToBi(step, message) {
    logBiWithEssentials(
      this._biLogger,
      pulseError({
        platform: this._platform,
        sessionId: this._sessionId,
        ...(this._msid && { msid: this._msid }),
        ...(this._vsi && { vsi: this._vsi }),
        ...(this._uuid && { uuid: this._uuid }),
        message,
        step,
      })
    );
  }
}
//# sourceMappingURL=pulse.js.map
